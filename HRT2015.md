# O(1) query time, O(n) space reachability for planar graphs

This paper: reduce the case from acyclic single-source graph to an acyclic s-t graph (Section 3), and reduce the case of acyclic in-out graph to an acyclic single-source graph (Section 4).

## Section 3: Acyclic single-source graph → s-t graph
In this section, we create a partition of the vertices of $G$ in the form of truncated $st$-graphs first. Then we use this decomposition to reduce reachability queries into the $st$-graph case.

### Part 1: st-decompositions
Create the st-decomposition* of an acyclic single-source planar graph $G=(V,E)$, which is a rooted tree with nodes that correspond to truncated $st$-graphs (where we can add sources/sinks to obtain an $st$-graph without violating planarity). This will allow us to reduce to the $st$ case.

The *st-decomposition* is obtained by recursively choosing faces of $G$ wisely and letting all the vertices that can reach vertices on this face $f$ belong to this *st-decomposition* node. Then we partition all remaining vertices amongst the descendants of this *st-decomposition* node within the rooted tree. An *st-decomposition* looks something like below.

![IMG_01A82F88F64F-1](https://user-images.githubusercontent.com/69584282/198895525-8593b6d7-0160-45a0-a45a-fd0e4f8942dd.jpeg)

All vertices are represented in exactly one st-decomp. node (a frame), and we select truncated st-graphs maximally so once a path crosses a frame, it does not exit the frame.
We select faces of $G$ recursively such that the *st-decomposition* has height $O(\log{n})$ and each frame has an alternation number of 2 (this is called a good st-decomposition).

**For given pair of vertices $u,v$, $u$ reaches $v$ in $G$ iff $u$ lies in a component of *st-decomposition* that is ancestral to $v$'s component.**

The reason for this is we know that the alternation number of any frame in an *st-decomposition* is at most 4, so between the frames of $u,v$ respectively there can be at most 4 best possible vertices that could reach $v$ within $u$ and $v$'s frame. So we use this level-ancestry system to find these candidate best vertices in the two frames. 

Once we can find these candidate vertices in constant time given our rooted tree structure, we have then reduced the single-source case into asking if any of these 4 candidate vertices reach the target vertex $v$ within a truncated st-graph (equivalence to the $st$-graph case).

More formally, if $u$ reaches $v$ where $u \in C_x, v \in C_y$ (i.e. $C_x = bc(f_x) - S_y$ for $x$ child of $y$) then either $x=y$ (they are in the same st-decomp node) or $x$ has a child $z$ that is ancestor of $y$ such that any $u$-to-$v$ path contains some vertex in $F_z$. To see this, observe below:

![IMG_4BA98B02A86C-1](https://user-images.githubusercontent.com/69584282/198897479-cc7efc12-213e-4db4-8612-b3ef874fa7d7.jpeg)

In other words we have to check the following cases to answer reachable(u,v): given $u \in C_x, v \in C_y$ and let $\preccurlyeq$ be ancestry of st-nodes in the st-decomposition.

1. if $x \not \preccurlyeq y$ (x is not an ancestor of y$ then $u$ cannot reach $v$.
2. if $x = y$ then answer is given in the $st$-graph labelling of $C_x$ (see Tamassia, Tollis)
3. If $x \prec y$ and there are no 2-frames that separate $u,v$ but there are 4-frames. Then we can compute the at most 4 best vertices in $C_x$ that can reach $v$. If $u$ can reach any of them then $u$ reaches $v$, otherwise no.
4. Else $x \prec y$ and there is a 2-frame $F_z$ separating $u,v$ such that there are no 2-frames between $x,z$. Then we can compute the at most 2 best vertices in $C_z$ that can reach $v$. If $u$ can reach any of them, then $u$ can reach $v$ otherwise no.

![IMG_A0A408222139-1](https://user-images.githubusercontent.com/69584282/198898930-db336fcb-e44b-48dd-a293-39bcc5d69f2c.jpeg)

### Part 2: constructing st-decompositions
Now that we've seen how the st-decomposition is helpful in answering reachability, we have to choose the faces of this st-decomposition carefully so it ends up having log-height.

In lemma 3.9 and 3.10, we show that first the faces of S (a subgraph of G where $S \cap T$ is connected) correspond to connected components of the dual spanning tree without edges in dual graph induced by $S$. Then we show that the subgraph of the cotree induced by the vertices in the dual graph including all faces contained in some st-decomposition node is a connected subtree. The intuition for these lemmas is below:

![IMG_CCD50E95F1DE-1](https://user-images.githubusercontent.com/69584282/198900070-1ac4138c-29c7-4393-80fb-ea0adabd7f38.jpeg)

Then in 3.11 and 3.12 we show that all children nodes of 2 or 4-frames must also have alternation number of at most 4.

![IMG_A854D2E34431-1](https://user-images.githubusercontent.com/69584282/198901594-3e07c6cc-43b6-4752-aaec-7bb039d7f517.jpeg)

Then we can show that for any acyclic planar single-source graph, a good s-t decomposition exists.

The proof constructs a good st-decomposition by recursively selecting faces from root downwards.
- If x is the root, we let $f_x$ be the median of $T'$. (For each child y, $|T'_x| \leq \frac{1}{2}|T'_x|$ and since we have $S_x = bc(f_x)$, the children parent frames have alt. no. 2).
- If $F_x$ has alt. no. 2: let $f_x$ be the median of $T'_x$. (Like above, children y will have $F_y$ with at most half size and by 3.11, has alt no. $\leq$ 4).
- If $F_x$ has alt. no. 4: let $f_x$ be projection of the median of $T'_x$ on the path from faces incident to both local targets of $F_x$ (we pick face close to the targets) in $T'_x$. By 3.12 this means the alt. no. is at most 4 and we have halving in size as well.

### Part 3: constructing a good *st-decomposition* in O(n)
Using prior work, we can improve the construction time of the st-decomposition by keeping track of the subtrees of $T'$, the cotree, and some information such that we can find $x$ (node of cotree) in $O(1)$ when $T'_x$ is a component at some point of the algorithm. 

Also for each node $x$ we keep the set of target vertices on $F_x$ (or $\emptyset$ if $x$ is root) and a face in $T'_x$ incident to the target each target in this set.

Then we build a $O(\log{n})$-height top tree over the cotree $T'$ and let $v'_{n-i}$ be the $i$th face that stops being a boundary during the construction (so boundary faces of a cluster are visited before boundary faces of their descendants), and we use this ordering to find splitting faces of the st-decomposition.

Then for each $v'_i$ (a face in graph), we find the relevant node $x$ to split using connectivity structure. If $x$ is the root or a 2-frame then we just set $f_x = v'_i$. If $x$ is a 4-frame though we use a static nearest common ancestor data structure to find $f_x = \pi(v'_i)$, the projection of $v'_i$ onto the path between the faces incident to the target.

Then we traverse graph backwards from vertices of $f_x$ until we have all edges with destination in $C_x$ and delete these edges from the forest as we go along. Once done, take all targets in $C_x$ and select an incident face for each component it is incident to. If $f_x \neq$ $v'_i$ we try again with ${v'}_i$ now with deleted edges otherwise move onto the next face.

(add picture of construction here)

### Part 4: 2-frames
We want to learn about the relationship between 2-frames (while disregarding the 4-frames) first. We construct a 2-frame decomposition from the $st$-decomposition which is a tree with nodes that are contracted subtrees (each node with a 4-frame is contracted with its nearest ancestor that has a 2-frame).

Let $\mathcal{T}$ be an st-decomposition of $G=(V,E)$, so we define a *2-frame-decomposition* $\mathcal{T_2}$ by contracting each st-edge $(z,y) \in \mathcal{T}$ where the child $z$ of $y$ has a 4-frame. For each node $x \in \mathcal{T_2}$ that is contracted from a set of nodes $Y \subseteq \mathcal{T}$ we define $C_x:= \bigcup_{y \in Y} C_y$, and if $x$ is not the root we let $F_x:= F_{lca(Y)}, E_x:= E_{lca(Y)}$.

$E_x$ are the edges with tail on $F_x$. If $F_x$ is a 2-frame, it has a clockwise and anticlockwise disegment — we can partition the edges of $E_x$ into contiguous subsets in the cyclic order given by the embedding of $G$ into sets $\mathcal{L,R}$ such that $E_x \cap \mathcal{L}$ and $E_x \cap \mathcal{R}$ form a partitioning of $E_x$. 

Let $(\mathcal{L,R})$ be the partition of the edges in the 2-frame decomposition: for each $(u,v) \in \bigcup_{x \in \mathcal{T_2}} E_x$ let $y$ be the node closest to the root of $\mathcal{T_2}$ such that $(u,v) \in E_y$ but $u$ is not the target vertex of $F_y$. See below for picture of $\mathcal{L,R}$ and the idea of $l_i(v), r_i(v)$ being the two best vertices that can reach $v$ on the node with same depth as $v$ itself.

![IMG_204CE947E716-1](https://user-images.githubusercontent.com/69584282/199070311-7964b107-ad00-43bd-85d8-1ee983ed38bd.jpeg)

Letting $L_i(v), \hat{L_i}(v), R_i(v), \hat{R_i}(v)$ be totally ordered by its starting vertex position on the disegments of $F_x$. Now our goal is to compute these two best vertices in an efficient way: roughly, by representing each function $l_i(v), r_i(v)$ with a rooted forest and use a level-ancestor structure on that forest to answer queries.

For vertices $v \in V$ we create rooted trees $T_l, T_r$ with parent pointers $p_l, p_r$ to define functions that will allow us to compute these two 'best' vertices easily. We define $p_l[v] = l_{d_2[v]-1}(v)$ if $d_2[v] \neq 0$, else $\perp$. Similarly, $p_r[v] = r_{d_2[v]-1}(v)$ if $d_2[v] \neq 0$, else $\perp$. Then we define the functions $l'_i(v), r'_i(v)$ as nearest ancestors to v in these rooted trees, $T_l, T_r$ respectively, that have depth at most $i$.

Specifically, we let $l'_i(v) = v$ if $v = \perp \vee d_2[v] \leq i$, else $l'_i(v) = l'_i(p_l[v])$ and $r'_i(v) = v$ if $v = \perp \vee d_2[v] \leq i$, else $r'_i(v) = r'_i(p_r[v])$. Then we have $l', r'$ are $v$ themselves or invoke a recursive call to the left (right, respectively) parent pointer, which will eventually get to the $d_2[v] \leq i$ case or $v = \perp$ case.

We do not always have $l'_i(v) = l_i(v), r'_i(v) = r_i(v)$. In a 2-frame decomposition $\mathcal{T_2}$, when we have an $F_y$ parent frame of $F_x$ then we have two possibilities for the best vertices on $F_y$ given the best vertices on $F_x$, call them $l,r$:
1. Left parent of $l$ and right parent of $r$ are the best vertices for $F_y$
2. There exists a 'crossing', i.e. the left parent of $r$ is 'later' in the disegment ordering than the left parent of $l$, making a the best vertex (similar could happen with right parent of $r$). This case is illustrated below:

![IMG_A0EE2B637AA0-1](https://user-images.githubusercontent.com/69584282/199115697-4e9b0937-a7df-4e25-9550-0131c81060bb.jpeg)

This implies the crossing lemma. For $v \in V$, and $0 \leq i < d_2[v]-1$, if we have $l_i(v) \neq l'_i(l_{i+1}(v))$, then $l_i(v) = l'_i(m) \wedge r_i(v) = r'_i(m) \wedge d_2[m] = i+1$, where $m=r_{i+1)(v) \neq \perp$. Similarly, $r_i(v) \neq r'_i(r_{i+1}(v))$ implies $l_i(v) = l'_i(m) \wedge r_i(v) = r'_i(m) \wedge d_2[v]=i+1$, where $m = l_{i+1}(v) \neq \perp$.

What this lemma says is: if there is a crossing at level $i$ then there must exist a crossing vertex $m \in \{ r_{i+1}(v), l_{i+1}(v) \}$ such that the left and right parents of $m$ are the best vertices that can reach $v$ on level $i$. 

So we define this $m_i(v)$ crossing vertex for $v \in $V$ and $0 \leq i < d_2[v]$ as this crossing vertex at level $i$ if it exists, else it is the nearest crossing vertex on a descendant level. 

In other words, $m_i(v):= v$ if $i+1 = d_2[v]$, $m_i(v) = l_{i+1}(v)$ of $i+1 < d_2[v]$ and $r_i(v) \neq r_{i}'((r_{i+1}(v))$, $m_i(v) = r_{i+1}(v)$ of $i+1 < d_2[v]$ and $r_i(v) \neq l_{i}'(l_{i+1}(v))$, and $m_i(v) = m_{i+1}(v)$ otherwise.

Then we can rewrite the $l_i(v), r_i(v)$ best vertices that can reach $v$ on level $i$ as $l_i(v) = l_{i}'(m_i(v))$ and $r_i(v) = r_{i}'(m_i(v))$. In other words, the candidate best vertices at depth $i$ to reach v are either $m_i(v)$ (this crossing vertex if it is at the right level), the best last vertex on $l$ or $r$ on level $i+1$ depending on which crossing condition is satisfied, or the nearest crossing vertex in its descendant levels.

Then to calculate these values of $l_i(v), r_i(v)$ quickly given a value for $i$, we should store a bit array for each level and then find left and right ancestors for that crossing vertex. So to represent $m_i(v)$ as a function we use a rooted forst so we can use level ancestor structure on that forest to answer queries. Specifically, let M[v]:= {$i | 0 < i< d_2[v], m_{i-1}(v) \neq m_i(v)$}, $p_m[v]:=m_{max M[v]-1}(v)$ if $M[v] \neq 0$, else $p_m[v]:= \perp$, with $T_m$ being the rooted forest with parent pointers $p_m[v]$.

The intuition is explained here:
![IMG_92A5C8EB06E9-1](https://user-images.githubusercontent.com/69584282/199306627-a7023552-8ef7-4f4b-9369-cbd33590ba64.jpeg)

Then the fast computation of $l_i, r_i$ exists by the following procedure. 

Let $G=(V,E)$ be a planar acyclic single-source graph with good st-decomposition. For any vertex $v \in V$, let D_l[v]:= { $i | v$ has a proper ancestor $w \in T_l$ with $d_2[w]=i$ } and D_r[v]:= { $i | v$ has a proper ancestor $w \in T_r$ with $d_2[w]=i$ }. Store level ancestor structures (so we can find ancestors quickly) for $T_l, T_r, T_m$. Additionally, also store $d_2[v], D_l[v], D_r[v], M[v]$ for each vertex. Since this good st-decomposition has height $O(log n)$ we can represent $D_l[v], D_r[v], M[v]$ in $O(log n)$ bit words each. 

Using this representation, we find $d_2[m_i(v)] = succ(M[v]\cup \{d_2[v]\},i)$ (ie. the depth in 2-frame decomp. of the crossing vertex at depth i, which is the $i$th successor of $M[v]\cup \{d_2[v]\}$), this can be done in $O(1)$ time. Then we can use the level ancestor structure for $T_m$ to compute $m_i(v)$ in constant time by knowing its depth. Doing something similar, we can compute the depth of $l_i'(v)$ in $T_l$ in constant time, and compute the depth of $l_i'(v)$ in the whole st-decomposition in constant time using the level ancestor structure of $T_l$, and do the same for $r_i'(v)$. Given the functions for $l_i(v), r_i(v)$ that we can compute in constant time we also have computed both best vertices in constant time.

### Part 5: 4-frames
We have now seen how to find at most two best vertices on $F$ that can reach $v$ when $F$ is a 2-frame, so we are left with the case for 4-frames (particularly edges that do not cross a 2-frame, because otherwise we can use the earlier method to get from the nearest descendant 2-frame to a given level). If we have a 4-frame whose parent frame is also a 4-frame then we know they share a target vertex.

We number the source and target nodes in $F_x$, a 4-frame, $s_x^0, t_x^0, s_x^1, t_x^1$ in clockwise cyclic order, and if $F_y$, its parent frame, is also a 4-frame, there must be some $\alpha \in 0,1$ such that $t_x^\alpha = t_y^\alpha$. Additionally, we partition these four disegments into: $\mathcal{R^\alpha}$ if it is on the disegment between $s_x^\alpha, t_x^\alpha$, and $\mathcal{L^\alpha}$ if it is on the disegment between $s_x^{1-\alpha}, t_x^\alpha$.

Let $\mathcal{T}$ be an st-decomposition of $G$, then for any vertex $v \in V$ we want to store the st-node corresponding to $v$, ie. $c[v]$, the depth of this st-node, $d[v]$, and 
the set of st-node depths of 2-frame, non-root ancestors to the node $c[v]$ in $\mathcal{T}$, $J_2[v]$. We also store the maximum of such depths in $j_2[v]$ for easy accessing, since we want to know when we have 4-frames nested in 4-frames, which happens after the last 2-frame (ie, when depth is $j_2[v]$) so we will consider $j_2[v] \leq i < d[v]$.

Now given a vertex $v$ and a 4-frame $F$ that is ancestral to $v$, we will define the (at most) 4 best vertices that can reach $v$ (ie. one for each disegment of $F$) called $l_i^0(v), r_i^0(v), l_i^1(v), r_i^1(v)$.

For any depth of nested 4-frames, i.e. $j_2[v] \leq i < d[v]$ and $\alpha \in 0,1$, with $x$ being the ancestor of $c[v]$ at depth $i+1$, we define: $F_i(v)=F_x, E_i(v) = E_x \cap \mathcal{E_4}, L_i^\alpha (v) = E_x \cap \mathcal{L^\alpha}, R_i^\alpha (v) = E_x \cap \mathcal{R^\alpha}, \hat{L_i^\alpha}(v) = $ all edges (w,w') in $L^\alpha_i(v)$ such that w' can reach $v$. Similar with $\hat{R_i^\alpha}(v)$ except $(w,w') \in R_i^{\alpha}(v)$, and let $\hat{F_i}(v):= \hat{L_i^0}(v) \cup \hat{R_i^0}(v) \cup \hat{L_i^1}(v) \cup \hat{R_i^1}(v)$ and define $s_i^\alpha(v), t_i^\alpha(v)$ as the vertices associated with $s_x^\alpha, t_x^\alpha$. The at most four best vertices then are $l_i^\alpha(v) =$ last vertex in tail( $\hat{L_i^\alpha}(v)$) on the counterclockwise dipath of $F_x$ if $\hat{L_i^\alpha}(v) \neq \emptyset$, and $r_i^\alpha(v) =$ last vertex in tail( $\hat{R_i^\alpha}(v)$) on the counterclockwise dipath of $F_x$ if $\hat{R_i^\alpha}(v) \neq \emptyset$.

And let the sets $L_i^\alpha(v), \hat{L_i^\alpha}(v)$ be totally ordered on the counterclockwise order around each starting vertex, and let $R_i^\alpha(v), \hat{R_i^\alpha}(v)$ be totally ordered on the clockwise order. Similar to the 2-frame case, we define some rooted forests that allow us to compute related functions to the at most 4 best vertices, and introduce a crossing lemme that lets us use these functions to compute these vertices efficiently.
